# 1. Stack for Browser History (20 points)
# List as Stack ADT
# Instructions: Create a browser history manager using a stack. When you visit pages, they get added to history. The "back" button removes the most recent page.

class BrowserHistory:
    def __init__(self):
        self.history = []  # This is our stack
    
    def visit_page(self, url):
        """
        Visit a new page (add to history).
        Print which page was visited.
        """
        new_page = url
        self.history.append(new_page)
        #Append the new page to history stack
        print(f"Visited: {new_page}")
        #Print the visited page in above format
    
    def go_back(self):
        """
        Go back to the previous page (remove most recent).
        Return the URL that was removed.
        If no history, return "No pages to go back to"
        """
        if self.history is not None:
            return self.history.pop()
            #Pop removes and returns the most recent page
        else:
            return "No pages to go back to"
            #If history is empty, return the above statement
    
    def current_page(self):
        """
        Return the current page (most recent) without removing it.
        If no history, return "No pages in history"
        """
        # YOUR CODE HERE
        peek = self.history 
        if self.history is not None:
            return peek
        else:
            "No pages in history"

    
    def show_history(self):
        """
        Print all pages in history, numbered from oldest to newest.
        If empty, print "No history"
        """
        if len(self.history) == 0:
            print("No history")
        else:
            for i in range(len(self.history)):
                page = self.history[i]
                print(f"Page: {page}")


# Test your code
browser = BrowserHistory()
browser.visit_page("google.com")
browser.visit_page("youtube.com")
browser.visit_page("github.com")
browser.visit_page("stackoverflow.com")

print("\n--- Current History ---")
browser.show_history()

print(f"\nCurrent page: {browser.current_page()}")

print("\n--- Going back ---")
removed = browser.go_back()
print(f"Went back from: {removed}")

print(f"\nCurrent page: {browser.current_page()}")

print("\n--- Current History ---")
browser.show_history()
"""
Expected Output:

Visited: google.com
Visited: youtube.com
Visited: github.com
Visited: stackoverflow.com

--- Current History ---
1. google.com
2. youtube.com
3. github.com
4. stackoverflow.com

Current page: stackoverflow.com

--- Going back ---
Went back from: stackoverflow.com

Current page: github.com

--- Current History ---
1. google.com
2. youtube.com
3. github.com
"""


# 2. Using Built-in Sort vs Manual Sort (10 points)
"""
Compare sorting approaches and understand when to use each.
Instructions:
- Create a list of 30 random numbers between 1-100
- Make two copies of this list
- Sort one copy using Python's built-in sort() method
- Sort the other copy using the selection_sort function provided below
- Print both results and verify they match
- Answer in comments: "When would you write your own sort vs using built-in sort?"
"""
def selection_sort(numbers):
   for i in range(len(numbers)-1):
      
      # Find index of smallest remaining element
      index_smallest = i
      for j in range(i+1, len(numbers)):
         
         if numbers[j] < numbers[index_smallest]:
            index_smallest = j
      
      # Swap numbers[i] and numbers[index_smallest]
      temp = numbers[i]
      numbers[i] = numbers[index_smallest]
      numbers[index_smallest] = temp

# Generate a list of 30 random numbers between 1-100
import random
random_numbers = [random.randint(1, 100) for i in range(30)]
# Make two copies of the list
list_copy1 = random_numbers.copy()
list_copy2 = random_numbers.copy()
# Sort using built-in sort
list_copy1.sort()
# Sort using selection_sort
selection_sort(list_copy2)
# Print both results
print("Built-in Sort: ", list_copy1)
print("Selection Sort: ", list_copy2)
# When would you write your own sort vs using built-in sort?
#There might be times where you need a customized sorting algorithm that the built in sort is not able to handle.
#This would occur if you had different sorting rules, so you could write your own code.

# 3. Recursive Functions (15 points)
# Instructions: Complete the recursive function that calculates the sum of all digits in a positive integer, and answer attached questions.
def sumDigits(n):
    """
    Recursively calculates the sum of all digits in a positive integer.
    
    Example: sumDigits(1234) returns 10 because 1 + 2 + 3 + 4 = 10
    """
    # Base case: if n is a single digit, return it
    if n < 10:
        return n
    
    # Recursive case: add last digit to sum of remaining digits
    return (n % 10) + sumDigits(n // 10)
    #Use modulo function with 10 to get the last digit


# Test your function
print(sumDigits(1234))  # Should print: 10
print(sumDigits(99))    # Should print: 18
print(sumDigits(5))     # Should print: 5
"""
sumDigits(1234) = 4 + sumDigits(123)
                    = 4 + 3 + sumDigits(12)
                        = 4 + 3 + 2 + sumDigits(1)
                            = 4 + 3 + 2 + 1
                            = 10
Key Operations:
- n % 10 → gets the last digit (1234 % 10 = 4)
- n // 10 → removes the last digit (1234 // 10 = 123)
"""
# What is the main difference between a recursive function and an iterative function (one using loops)?
# A recursive function refers to itself to solve sub-problems within the main problem. An iterative function uses loops to repeat a process while some condition is true.

# Can every recursive function be written iteratively? Can every iterative function be written recursively?
#I think so, but it may make the code more confusing and prone to errors if you repeat it over in that way. 
#I don't think that every iterative function can be written recursively, because that is not necessary depending on the task at hand.
# Give one advantage and one disadvantage of using recursion.